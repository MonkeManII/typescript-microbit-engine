{"entries":[{"timestamp":1748041179407,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"clearScreen.ts","patch":[{"diffs":[[0,"s {\n"],[-1,"    /**\n     * Resets all pins on the screen to be off.\n     */\n"],[0,"    "]],"start1":14,"start2":14,"length1":72,"length2":8}]},{"type":"edited","filename":"gameObjects.ts","patch":[{"diffs":[[0,"    "],[-1,"/**\n     * A class for all non-static objects.\n     */\n    export class GameObject {\n        /**\n         * The position of this gameobject relative to the top left corner of the map.\n         */\n        position: Vector2 = Vector2.zero;\n        \n        /**\n         * How bright the pin is when rendering this object.\n         */\n        brightness: number = 0;\n\n        /**\n         * Where on the 'objects' list this is located.\n         */"],[1,"export class GameObject {\n        position: Vector2 = Vector2.zero;\n        brightness: number = 0;\n"],[0,"\n   "]],"start1":19,"start2":19,"length1":452,"length2":108},{"diffs":[[0," }\n\n"],[-1,"        /**\n         * Called when another object is deleted.\n         * Shifts the index of this down if necessary.\n         */\n"],[0,"    "]],"start1":381,"start2":381,"length1":137,"length2":8},{"diffs":[[0," }\n\n"],[-1,"        /**\n         * Moves this a certain amount on the X axis.\n         * Checks for collisions along the way.\n         */\n"],[0,"    "]],"start1":529,"start2":529,"length1":134,"length2":8},{"diffs":[[0," }\n\n"],[-1,"        /**\n         * Moves this a certain amount on the Y axis.\n         * Checks for collisions along the way.\n         */\n"],[0,"    "]],"start1":923,"start2":923,"length1":134,"length2":8},{"diffs":[[0," }\n\n"],[-1,"        /**\n         * Checks to see if this object overlaps any tiles.\n         */\n"],[0,"    "]],"start1":1317,"start2":1317,"length1":92,"length2":8},{"diffs":[[0," }\n\n"],[-1,"        /**\n         * Deletes this object.\n         */\n"],[0,"    "]],"start1":2729,"start2":2729,"length1":64,"length2":8},{"diffs":[[0," }\n\n"],[-1,"        /**\n         * Draws this to the screen\n         */\n"],[0,"    "]],"start1":2991,"start2":2991,"length1":68,"length2":8},{"diffs":[[0," }\n\n"],[-1,"        /**\n         * Called every frame.\n         * Used to update objects each frame (like the player).\n         */\n"],[0,"    "]],"start1":3365,"start2":3365,"length1":127,"length2":8}]},{"type":"edited","filename":"input.ts","patch":[{"diffs":[[0,"    "],[-1,"/**\n     * A class to sort of merge the functionality of pins and buttons.\n     */\n    export class Input {\n        /**\n         * The button to use, if applicable.\n         */"],[1,"export class Input {"],[0,"\n   "]],"start1":19,"start2":19,"length1":184,"length2":28},{"diffs":[[0," }\n\n"],[-1,"        /**\n         * Returns whether or not this input is being held.\n         */\n"],[0,"    "]],"start1":452,"start2":452,"length1":92,"length2":8}]},{"type":"edited","filename":"level.ts","patch":[{"diffs":[[0,"e {\n"],[-1,"    /**\n     * A level.\n     */\n"],[0,"    "]],"start1":15,"start2":15,"length1":40,"length2":8}]}]},{"timestamp":1748041777718,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"input.ts","patch":[{"diffs":[[0,"    "],[-1,"/**\n         * The pin to use, if applicable.\n         */\n        private pin: TouchPin;\n        /**\n         * Whether to use the pin or the button.\n         */"],[1,"private pin: TouchPin;"],[0,"\n   "]],"start1":236,"start2":236,"length1":169,"length2":30}]},{"type":"edited","filename":"random.ts","patch":[{"diffs":[[0,"    "],[-1,"/**\r\n     * An abstract class containing various utilities for psuedorandom numbers.\r\n     */\r\n    export abstract class Random {\r\n        /**\r\n         * Generates a random integer from min-max (inclusive)\r\n         */"],[1,"export abstract class Random {"],[0,"\r\n  "]],"start1":19,"start2":19,"length1":227,"length2":38},{"diffs":[[0,"max));\r\n"],[1,""],[0,"        "]],"start1":169,"start2":169,"length1":16,"length2":16},{"diffs":[[0," }\r\n"],[-1,"        /**\r\n         * Generates a random decimal from min-max (inclusive)\r\n         */\r\n"],[0,"    "]],"start1":184,"start2":184,"length1":98,"length2":8}]},{"type":"edited","filename":"vector.ts","patch":[{"diffs":[[0,"    "],[-1,"/**\n     * A vector containing 2 numbers (x and y)\n     */\n    export class Vector2 {\n        /**\n         * The X component of this vector.\n         */\n        x: number;\n\n        /**\n         * The Y component of this vector.\n         */\n        y: number;\n\n        /**\n         * (0, 0)\n         */\n        static zero = new Vector2(0, 0);\n        /**\n         * (1, 1)\n         */\n        static one = new Vector2(0, 0);\n        /**\n         * (0, 1)\n         */\n        static up = new Vector2(0, 1);\n        /**\n         * (0, -1)\n         */\n        static down = new Vector2(0, -1);\n        /**\n         * (-1, 0)\n         */\n        static left = new Vector2(-1, 0);\n        /**\n         * (1, 0)\n         */"],[1,"export class Vector2 {\n        x: number;\n        y: number;\n\n        static zero = new Vector2(0, 0);\n        static one = new Vector2(0, 0);\n        static up = new Vector2(0, 1);\n        static down = new Vector2(0, -1);\n        static left = new Vector2(-1, 0);"],[0,"\n   "]],"start1":19,"start2":19,"length1":725,"length2":273},{"diffs":[[0," }\n\n"],[-1,"        /**\n         * Generates a random vector from (min, min) to (max, max) (inclusive)\n         */\n"],[0,"    "]],"start1":431,"start2":431,"length1":111,"length2":8},{"diffs":[[0," }\n\n"],[-1,"        /**\n         * Converts this vector to a string formatted as \"(x, y)\"\n         */\n"],[0,"    "]],"start1":644,"start2":644,"length1":98,"length2":8},{"diffs":[[0," }\n\n"],[-1,"        /**\n         * Copies the vector because classes are a bitch\n         */\n"],[0,"    "]],"start1":729,"start2":729,"length1":89,"length2":8},{"diffs":[[0," }\n\n"],[-1,"        /**\n         * Rounds each component of this vector to the nearest integer.\n         */\n"],[0,"    "]],"start1":814,"start2":814,"length1":104,"length2":8},{"diffs":[[0," }\n\n"],[-1,"        /**\n         * this + other\n         */\n"],[0,"    "]],"start1":924,"start2":924,"length1":56,"length2":8},{"diffs":[[0," }\n\n"],[-1,"        /**\n         * this - other\n         */\n"],[0,"    "]],"start1":1042,"start2":1042,"length1":56,"length2":8},{"diffs":[[0," }\n\n"],[-1,"        /**\n         * this * other\n         */\n"],[0,"    "]],"start1":1167,"start2":1167,"length1":56,"length2":8},{"diffs":[[0," }\n\n"],[-1,"        /**\n         * this / other\n         */\n"],[0,"    "]],"start1":1285,"start2":1285,"length1":56,"length2":8}]}]},{"timestamp":1748042647240,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":341,"start2":341,"length1":52,"length2":8}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"}]}],"snapshots":[{"timestamp":1748041179406,"editorVersion":"7.0.61","text":{"main.ts":"class Player extends Engine.GameObject {\n    constructor(position: Engine.Vector2) {\n        super(position, 255);\n    }\n\n    tick(): void {\n        if (inputs[0].Get()) {\n            this.moveX(-0.3);\n        }\n        if (inputs[1].Get()) {\n            this.moveX(0.3);\n        }\n        if (inputs[2].Get()) {\n            this.moveY(0.3);\n        }\n        if (inputs[3].Get()) {\n            this.moveY(-0.3);\n        }\n    }\n}\n\nconst inputs: Engine.Input[] = [\n    new Engine.Input(null, TouchPin.P0),\n    new Engine.Input(null, TouchPin.P1),\n    new Engine.Input(null, TouchPin.P2),\n    new Engine.Input(Button.A, null),\n];\n\nlet objects: Engine.GameObject[] = [];\nlet currentLevel: Engine.Level;\nlet player: Player = null;\nlet camera: Engine.Vector2 = Engine.Vector2.zero;\n\nconst framesPerSecond: number = 30\n\nfunction startLevel(level: Engine.Level): void {\n    objects = [];\n    currentLevel = level;\n    player = new Player(level.startPosition.subtractBy(Engine.Vector2.one));\n}\n\n\nstartLevel(Engine.Level.Generate(30, 30));\n\nfunction draw(): void {    \n    Utils.clearScreen();\n    camera = player.position.copy();\n    camera.x -= 2;\n    camera.y -= 2;\n    currentLevel.draw(camera);\n    for (let i: number = 0; i < objects.length; i++) {\n        objects[i].tick();\n        objects[i].draw(camera);\n    }\n}\n\nloops.everyInterval(Math.round((1 / framesPerSecond) * 1000), draw);","README.md":"","random.ts":"namespace Utils {\r\n    export abstract class Random {\r\n        static randInt(min: number, max: number): number {\r\n            return Math.round(Random.randDecimal(min, max));\r\n        }\r\n        static randDecimal(min: number, max: number): number {\r\n            return (Math.random() * (max - min)) + min;\r\n        }\r\n    }\r\n}","gameObjects.ts":"namespace Engine {\n    export class GameObject {\n        position: Vector2 = Vector2.zero;\n        brightness: number = 0;\n\n        private index: number = 0;\n\n        constructor(position: Vector2, brightness: number) {\n            this.position = position;\n            this.brightness = brightness;\n            this.index = objects.length;\n            objects.push(this);\n        }\n\n        onOtherKilled(otherIndex: number): void {\n            if (otherIndex < this.index) {\n                this.index--;\n            }\n        }\n\n        moveX(amount: number): void {\n            for (let i: number = 0; i < Math.abs(amount) * 10; i++) {\n                this.position.x += amount / 10;\n\n                if (this.collision()) {\n                    while (this.collision()) {\n                        this.position.x -= amount / 100;\n                    }\n                    return;\n                }\n            }\n        }\n\n        moveY(amount: number): void {\n            for (let i: number = 0; i < Math.abs(amount) * 10; i++) {\n                this.position.y += amount / 10;\n\n                if (this.collision()) {\n                    while (this.collision()) {\n                        this.position.y -= amount / 100;\n                    }\n                    return;\n                }\n            }\n        }\n\n        collision(): boolean {\n            let possibleCollisionTiles: number[] = [];\n            let basePosition: Vector2 = this.position.round();\n\n            for (let i: number = -2; i < 3; i++) {\n                for (let j: number = -2; j < 3; j++) {\n                    possibleCollisionTiles.push(i + basePosition.x + ((j + basePosition.y) * currentLevel.width));\n                }\n            }\n            \n            for (let i: number = 0; i < possibleCollisionTiles.length; i++) {\n                let tileIndex: number = possibleCollisionTiles[i];\n                let tileType: boolean = currentLevel.tiles[tileIndex];\n                let tilePosition: Vector2 = new Vector2(\n                    tileIndex % currentLevel.width,\n                    Math.floor(tileIndex / currentLevel.width),\n                );\n\n                if (tileType) {\n                    if (this.position.x + 0.5 > tilePosition.x - 0.5) {\n                        if (this.position.y + 0.5 > tilePosition.y - 0.5) {\n                            if (this.position.x - 0.5 < tilePosition.x + 0.5) {\n                                if (this.position.y - 0.5 < tilePosition.y + 0.5) {\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            \n            return false;\n        }\n\n        kill(): void {\n            for (let i = 0; i < objects.length; i++) {\n                if (i !== this.index) {\n                    objects[i].onOtherKilled(this.index);\n                }\n            }\n            objects.splice(this.index, 1);\n        }\n\n        draw(camera: Vector2): void {\n            let drawPos: Vector2 = this.position.subtractBy(camera).add(Vector2.one.multiply(2)).round();\n            if (drawPos.x >= 0 && drawPos.x <= 4) {\n                if (drawPos.y >= 0 && drawPos.y <= 4) {\n                    led.plotBrightness(drawPos.x, drawPos.y, this.brightness);\n                }\n            }\n        }\n\n        tick(): void {}\n    }\n}","vector.ts":"namespace Engine {\n    export class Vector2 {\n        x: number;\n        y: number;\n\n        static zero = new Vector2(0, 0);\n        static one = new Vector2(0, 0);\n        static up = new Vector2(0, 1);\n        static down = new Vector2(0, -1);\n        static left = new Vector2(-1, 0);\n        static right = new Vector2(1, 0);\n\n        constructor(x: number, y: number) {\n            this.x = x;\n            this.y = y;\n        }\n\n        static random(min: Vector2, max: Vector2) {\n            return new Vector2(\n                Utils.Random.randInt(min.x, max.x),\n                Utils.Random.randInt(min.y, max.y)\n            );\n        }\n\n        toString(): string {\n            return `(${this.x}, ${this.y})`;\n        }\n\n        copy(): Vector2 {\n            return new Vector2(this.x, this.y);\n        }\n\n        round(): Vector2 {\n            return new Vector2(Math.round(this.x), Math.round(this.y));\n        }\n\n        add(other: Vector2): Vector2 {\n            return new Vector2(this.x + other.x, this.y + other.y);\n        }\n\n        subtractBy(other: Vector2): Vector2 {\n            return new Vector2(this.x - other.x, this.y - other.y);\n        }\n\n        multiply(other: number): Vector2 {\n            return new Vector2(this.x * other, this.y * other);\n        }\n\n        divideBy(other: number): Vector2 {\n            if (other === 0) {\n                console.error(\"Vector2 division by zero!\");\n                return Vector2.zero;\n            } else {\n                return new Vector2(this.x / other, this.y / other);\n            }\n        }\n    }\n}","level.ts":"namespace Engine {\n    export class Level {\n        tiles: boolean[] = [];\n        width: number;\n        height: number;\n        startPosition: Vector2;\n\n        constructor(width: number, height: number) {\n            this.width = width;\n            this.height = height;\n            this.startPosition = Vector2.zero;\n\n            for (let i: number = 0; i < width*height; i++) {\n                this.tiles.push(true);\n            }\n        }\n\n        draw(camera: Vector2) {\n            for (let i: number = -2; i < 3; i++) {\n                for (let j: number = -2; j < 3; j++) {\n                    let tilePosition: Vector2 = camera.add(new Vector2(i + 2, j + 2));\n                    let tileType: boolean = this.GetTileAt(tilePosition);\n                    let visiblePosition: Vector2 = tilePosition.subtractBy(camera);\n\n                    if (tileType) {\n                        led.plotBrightness(visiblePosition.x, visiblePosition.y, 50);\n                    }\n                }\n            }\n        }\n\n        PosIsInBounds(position: Vector2): boolean {\n            if (position.x >= 0 && position.x < this.width) {\n                if (position.y >= 0 && position.y < this.height) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        GetTileAt(position: Vector2): boolean {\n            position = position.round();\n            if (this.PosIsInBounds(position)) {\n                return this.tiles[position.x + (position.y * this.width)];\n            } else {\n                return false;\n            }\n        }\n\n        SetTileAt(position: Vector2, value: boolean): void {\n            position = position.round();\n            if (this.PosIsInBounds(position)) {\n                this.tiles[position.x + (position.y * this.width)] = value;\n            }\n        }\n\n        SetSquareAt(position: Vector2, size: Vector2, value: boolean) {\n            position = position.subtractBy(size.divideBy(2).round());\n\n            for (let i: number = 0; i < size.x; i++) {\n                for (let j: number = 0; j < size.y; j++) {\n                    this.SetTileAt(position.add(new Vector2(i, j)), value);\n                }\n            }\n        }\n\n        static Generate(width: number, height: number): Level {\n            let level: Level = new Level(width, height);\n\n            level.startPosition = Vector2.random(\n                new Vector2(3, 3),\n                new Vector2(width - 3, height - 3)\n            );\n\n            level.SetSquareAt(level.startPosition, new Vector2(5, 5), false);\n            \n            return level;\n        }\n    }\n}","input.ts":"namespace Engine {\n    export class Input {\n        private button: Button;\n        private pin: TouchPin;\n        private isPin: boolean;\n\n        constructor(btn: Button=null, pin: TouchPin=null) {\n            if (btn === null) {\n                this.pin=pin;\n                this.isPin=true;\n                return;\n            } else {\n                this.button=btn;\n                this.isPin=false;\n                return;\n            }\n        }\n\n        Get(): boolean {\n            if (this.isPin) {\n                return input.pinIsPressed(this.pin);\n            } else {\n                return input.buttonIsPressed(this.button);\n            }\n        }\n    }\n}","clearScreen.ts":"namespace Utils {\n    export function clearScreen(): void {\n        for (let i = 0; i < 5; i++) {\n            for (let j = 0; j < 5; j++) {\n                led.unplot(i, j);\n            }\n        }\n    }\n}","pxt.json":"{\n    \"name\": \"Game Engine\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"random.ts\",\n        \"gameObjects.ts\",\n        \"vector.ts\",\n        \"level.ts\",\n        \"input.ts\",\n        \"clearScreen.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v7.0.61\",\n        \"tag\": \"v7.0.61\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/1bb8145a013b8c3718bf6c82138e87e3ecb5514d\",\n        \"target\": \"7.0.61\",\n        \"pxt\": \"11.1.14\"\n    },\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}}],"shares":[],"lastSaveTime":1748042647250}